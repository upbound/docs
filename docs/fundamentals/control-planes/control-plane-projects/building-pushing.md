---
title: Building and pushing your Control Plane Projects
sidebar_position: 1
description: How to build and push your control plane project to the Upbound Marketplace
---
Control plane projects are source-level representations of your control plane.
Like any other software project, control plane projects require a **build
stage** to assemble all parts of your project into a versioned artifact. Upbound
enables you to build and deploy control plane projects with the Upbound CLI.

## Build your control plane project

You can build the dependencies and metadata in your Upbound project as a single
OCI image with the [up project build][up-project-build]
command. This command builds functions, generates language-specific schemas, and
packages everything into a single `.uppkg` file. New builds update the control
plane project dependency cache in the same way running the [up dependency update-cache][up-dependency-update-cache] command does.

```shell
up project build
```

This command builds the image in your control plane project directory in `_output/<userProject>.uppkg`.

## Pushing your control plane project to the Upbound Marketplace

First, login to Upbound.

```shell
up login
```

After you log in, run `up project push` to push your package to the Upbound
Marketplace.

```shell
up project push
```
<!-- vale gitlab.SentenceLength = NO -->
If you don't have a Marketplace repository, the [up project push][up-project-push] command automatically creates the
repository based on the `spec.repository` field in your `upbound.yaml` file.
When you push a project with embedded functions, Upbound automatically creates
sub-repositories for these functions.
<!-- vale gitlab.SentenceLength = YES -->

<!--- TODO(tr0njavolta): links --->
## Use an embedded function

When you create functions with up function generate, the up CLI automatically adds them to the specified composition. For manually created functions or those shared across multiple compositions, reference them in the `functionRef` parameter.

The `functionRef` name follows this format: `[organization-name]-[project-name][function-name]`. For example, if your organization is `my-org` and your project is `my-conf`, the `functionRef` name would be:

```yaml
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: xexample.myorg.com
spec:
  mode: Pipeline
  pipeline:
    - step: compose
      functionRef:
        name: my-org-my-confcompose-xexample
    - step: propagate-status
      functionRef:
        name: my-org-my-confpropagate-status
```
### Build your configuration deployment

The `up project build` command builds and packages your
configuration and embedded functions.

Here's how it works:

**Build embedded function packages**:

<!-- vale write-good.Passive = NO -->

Each function in the project `functions/` directory is built into a
Crossplane function package by adding your code to a base image and generating
metadata.
<!-- vale write-good.Passive = YES -->


**Generate Configuration Package Metadata**:

The up CLI creates Crossplane configuration package metadata based on your
project, including dependencies on the embedded functions.

<!-- vale write-good.Passive = NO -->

**Build the Configuration Package**:

All relevant YAML files (XRDs and compositions) are bundled into a Crossplane
configuration package using the generated metadata.

<!-- vale gitlab.SentenceLength = NO -->

**Write the Packages to Disk**:
Embedded function and configuration packages are
saved to a single `.uppkg` file, which `up project push` can use to push
packages to the Upbound Marketplace.
<!-- vale gitlab.SentenceLength = YES -->
<!-- vale write-good.Passive = YES -->

### Push your configuration

The `up project push` command uploads your configuration and it's embedded
functions to the Upbound Marketplace.

<!-- vale write-good.Passive = NO -->

The `.uppkg` file generated by up project build contains the packages that need
to be pushed. Then the packages are pushed to sub-repositories
within your configuration repository. Each sub-repository name follows this
naming convention `[organization-name]/[project-name]_[function-name]`. The
configuration package, which includes dependencies on embedded functions, is
also pushed. Once uploaded, your configuration is ready to be deployed to
control planes like any
other configuration.
<!-- vale write-good.Passive = YES -->

Note that embedded functions require Crossplane 1.18 or later.

[up-project-push]: /apis-cli/cli-reference
[up-project-build]: /apis-cli/cli-reference
[up-dependency-update-cache]: /apis-cli/cli-reference
